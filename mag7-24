//final int minX=-0, maxX=100, minY=-100, maxY=100;
float inclination;
int halfWidth=50, depth=100;

Point[] points;

void setup() {
  size(1000, 1000); 
  background(128);
  stroke(0);
  strokeWeight(4);
    //x axis
    line(10, .75*height, width-10, .75*height);
    //y axis
    line(75, 10, 75, height-10);
    //tick marks
    line(60,.375*height,75,.375*height);
        line(60,.01*height,75,.01*height);
        //labels
        textAlign(RIGHT);
        text("-500", 60, .745*height);
        text("0", 58, .379*height);
        text("+500", 60, .014*height);

    //labels
    textAlign(CENTER);
    text("nT", 20, 350);
    text("Depth", 20, 850);
    text("Inclination of Vector of Magnetization", 875, .845*height);
    text("S", 10, .765*height);
    text("N", width-10, .765*height);
    //dike
    fill(255,0,0);
    rect(515-halfWidth, .75*height+depth, halfWidth*2, halfWidth*2);
  points = new Point[100];
  for (int i=0; i<points.length; i++) {
    points[i] = new Point(i*10, 0);
  }
}

void draw() {
  noStroke();
  fill(128);
  //rect for graph
 rect(79,0,width-20,.746*height);
 //rect around arrow
 rect(800, .854*height, 125, 100);
 stroke(255,0,0);
 line(800,900,900,900);
 line(850,850,850,950);
 stroke(0);
  arrow(850, 900, 50, inclination);

  for (int i=0; i<points.length; i++) {
    points[i].update();
    points[i].display();
  }
}

void arrow(float x, float y, int len, float angle) {
  pushMatrix();
  translate(x, y);
  rotate(angle);
  line(0, 0, len, 0);
  line(len, 0, len - 6, -6);
  line(len, 0, len - 6, 6);
  popMatrix();
}

void mouseDragged() {
  inclination=constrain(atan((mouseY-800.)/(mouseX-800.)), -QUARTER_PI, QUARTER_PI);
}

class Point {
  int x, y, declination;
  float theta, jx, jz, a, b, T, J_intensity=1000;
  Point(int x, int y) {
    this.x=x;
    this.y=y;
    this.declination=0;
  }
  void update() {
    /* ia is the component of the inclination of the 
     vector of magnetization in the direction of x */

    /* theta is the angle between the dipping 
     dike and the inclination of the vector of 
     magnetization projected in the x direction */
    theta = -HALF_PI - atan2(tan(degrees(inclination)), sin(declination)); 

    /* compute the components of magnetization wrt theta */
    jx = J_intensity*sin(theta);
    jz = J_intensity*cos(theta);

    //x = ( i - 1000) * 10;
    a = -2.0*halfWidth*(jx*sin(degrees(inclination)) + jz*cos(degrees(inclination))*sin(declination));
    b = 2.0*halfWidth*(-jx*cos(degrees(inclination))*sin(declination) + jz*sin(degrees(inclination)));
    T = (float)(a*x + b*depth)/(x*x + depth*depth);
    println(inclination);
    y = constrain(parseInt(.375*height-T*140/14.), 0, 739);
  }
  void display() {
    stroke(0);
    strokeWeight(2);
    fill(255);
    ellipse(constrain(x,85,width), y, 10, 10);
  }
}
//void drawAxes() {
//  stroke(0);
//  strokeWeight(4);
//  //x axis
//  line(10, abs((float)maxX)/(abs(maxX)+abs(minX))*(height-20), width-10, abs((float)maxX)/(abs(maxX)+abs(minX))*(height-20));
//}
