//final int minX=-0, maxX=100, minY=-100, maxY=100;
float inclination=30;
int halfWidth=75, depth=50, scaledHalfWidth;

Point[] points;
Slider wid;
Slider dep;

void setup() {
  size(1000, 1000); 
  background(128);
  stroke(0);
  strokeWeight(4);
  //x axis
  line(.010*width, .75*height, .990*width, .75*height);
  //y axis
  line(.075*width, .010*height, .075*width, .990*height);
  //tick marks
  line(.060*width, .375*height, .075*width, .375*height);
  line(.060*width, .01*height, .075*width, .01*height);
  //labels
  textAlign(RIGHT);
  text("-500", .060*width, .745*height);
  text("0", .058*width, .379*height);
  text("+500", .060*width, .014*height);

  //labels
  textAlign(CENTER);
  text("nT", .020*width, .350*height);
  text("Depth", .020*width, .850*height);
  text("Inclination of Vector of Magnetization", .875*width, .840*height);
  text("S", .010*width, .765*height);
  text("N", .99*width, .765*height);
  //dike
  scaledHalfWidth = parseInt(halfWidth/1000.*.456*width);
  fill(255, 0, 0);
  rect(.535*width-scaledHalfWidth, depth/100.*.25*height+.75*height, scaledHalfWidth*2, scaledHalfWidth*2);
  points = new Point[100];
  for (int i=0; i<points.length; i++) {
    points[i] = new Point(parseInt(i-points.length/2.)*20, 0);
  }
  //must use parseInt() instead of (int)
  wid=new Slider(parseInt(.800*width), parseInt(.880*height), parseInt(.100*width), parseInt(.030*height), 0, 100, 50);
  dep=new Slider(parseInt(.800*width), parseInt(.940*height), parseInt(.100*width), parseInt(.030*height), 0, 100, 50);
}

void draw() {
  noStroke();
  fill(128);
  //rect for graph
  //rect(.079*width, 0, width-20, .746*height);

  for (int i=0; i<points.length; i++) {
    points[i].update();
    points[i].display();
  }
}
//void mouseDragged() {
//  inclination=constrain(atan((mouseY-.900*height)/abs(mouseX-.850*width)), -QUARTER_PI, QUARTER_PI);
//}

class Point {
  int  x, y, declination, scaledX;
  float theta, jx, jz, a, b, T, J_intensity=200, dipAngle;
  Point(int x, int y) {
    this.x=x;
    this.y=y;
    this.declination=0;
  }
  void update() {
    /* ia is the component of the inclination of the 
     vector of magnetization in the direction of x */

    /* theta is the angle between the dipping 
     dike and the inclination of the vector of 
     magnetization projected in the x direction */
    theta = dipAngle - atan2(tan(degrees(inclination)), sin(declination)); 

    /* compute the components of magnetization wrt theta */
    jx = J_intensity*sin(theta);
    jz = J_intensity*cos(theta);


    a = -2.0*halfWidth*(jx*sin(degrees(inclination)) + jz*cos(degrees(inclination))*sin(declination));
    b = 2.0*halfWidth*(-jx*cos(degrees(inclination))*sin(declination) + jz*sin(degrees(inclination)));
    T = (float)(a*x + b*depth)/(x*x + depth*depth);
    println(T);
    y = constrain(parseInt(.375*height-(T/1000.*.375*width)), 0, parseInt(.739*height));
    scaledX = parseInt(.535*width-x/1000.*.456*width);
  }
  void display() {
    stroke(0);
    strokeWeight(1);
    fill(255);
    ellipse(constrain(scaledX, .085*width, width), y, .010*width, .010*height);
  }
}
class Slider {
  int x, y, w, h, currentPixels;
  float min, max, current;
  Slider(int x, int y, int w, int h, float min, float max, float initial) {
    this.x=x;
    this.y=y;
    this.w=w;
    this.h=h;
    this.min=min;
    this.max=max;
    current=initial;
    currentPixels=this.dataToPixels();
    fill(51, 51, 204);
    noStroke();
    rect(x, y, w, h);
    fill(0, 100, 0);
    rect(x, y, currentPixels, h);
  }

  boolean mouseOver() {
    if (mouseX>x&&mouseX<w+x) {
      if (mouseY>y&&mouseY<h+y) {
        return true;
      }
    }
    return false;
  }
  void update() {
    currentPixels=constrain(mouseX-x, 0, w);
    fill(51, 51, 204);
    noStroke();
    rect(x, y, w, h);

    fill(0, 100, 0);
    rect(x, y, currentPixels, h);
    current=pixelsToData();
    fill(255);
    text(current, x+w/3, y+h/2);
  }
  float pixelsToData() {
    return (float)currentPixels/w*(max-min)+min;
  }
  int dataToPixels() {
    return parseInt(current/(max-min)*w);
  }
}
void mouseDragged() {
  if (wid.mouseOver()) {
    wid.update();
  }
  if (dep.mouseOver()) {
    dep.update();
  }
}
